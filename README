***NOTE to XAMPP users on Windows:
It seems XAMPP comes with openssl but you might need to configure it before it
will work. You should do this before using randomness. Take a look at:
xampp\php\extras\openssl\README-SSL.txt

randomness
==========

The Yii application component in protected/components provides four handy
helper functions for using in web apps that need to handle passwords.

There are many tutorials and examples that show storage of passwords in a table.
Often the methods used are substandard and very easy to crack. For example, the
"Agile Yii" book's example stores md5($password) in the DB and calls it
"encryption". It is not. "The Definitive Guide to Yii" is a little better in
that it uses a salt but it still uses md5 and is easy to crack.

You cannot rely on a user to use a (practically) unguessable password or to not
use that password in systems other than yours. And you should not assume that
your server is so secure that an attacker cannot get hold of the password file.

So you use a salt to ensure that the hash is unlikely to appear in any
dictionary or rainbow. But this is not enough. First, the salt has to be really
random. Second, the hash function needs to be slow to calculate (computationally
expensive, as the techies say).

Frist problem: a common mistake is to generate salts with mt_rand() or similar.
That's no use because mt_rand is a simple pseudo-random number gnerator designed
for use in Monte Carlo simulations, not in security systems. It is not
cryptographically secure (not a CSPRNG). You can determine the next random
number from previous ones or from knowing the internal state of the generator.

Randomness uses the operating system's CSPRNG if it can. If it can't, it logs
a warning and falls back to something less secure. In the case that neither
openssl_random_pseudo_bytes() nor /dev/random work it falls back on its own
own stupid tricks to shuffle things up (read the code).

In most decent production environments, be it Windows, Unix or Linux, Randomness
will return a good, CS random value and not use any hackery. But test it out to
see how it works for you by checking your logs (Yii logs, not PHP error log).

The second problem is fast hashes. MD5, for example, is very fast. As of Nov
2011 you can check 350 million keys per second on a commodity nVidia processor.
So no matter what you do with salts, the combination of short passwords and fast
brute force checking means your system is open to intruders if you rely on a
non-iterated message digest such as md5, SHA and the rest.

Blowfish is currently considered pretty good. It is designed to be slow. The
implementation in PHP's crypt() is easy to use. Set a cost parameter high enough
to make a brute force attack really slow. I set it so that it takes about 250 ms
on the production server (a completely arbitrary choice:-).

Randomness::blowfishSalt() generates a salt to use with crypt(), for example:

    $user = new User;
    $user->email = $form->email;
    $user->bf_hash = crypt($form->password, Randomness::blowfishSalt());
    if ($user->save())
        ...

To authenticate:

    public function authenticate() {
        $user = User::model()->findByAttributes(array(
            'email' => $this->username,
        ));
        if ($user === null
            || crypt($this->password, $user->bf_hash) !== $user->bf_hash
        )
            $this->errorCode = self::ERROR_UNKNOWN_IDENTITY;
        ...

Some people advocate resalting every time a user logs in. I think this is only
useful if you also limit the time interval between user logins, e.g. block an
account if the user hasn't logged in in more than N weeks.

Randomness::randomString() might come in handy for generating a random password
if you ever need to give one to a user.